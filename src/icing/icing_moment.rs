//! –£—á–µ—Ç –º–æ–º–µ–Ω—Ç–∞ –º–∞—Å—Å—ã –ª—å–¥–∞
use std::rc::Rc;
use crate::ILoad;

/// –£—á–µ—Ç –º–æ–º–µ–Ω—Ç–∞ –º–∞—Å—Å—ã –ª—å–¥–∞ –ø—Ä–∏ –æ–±–ª–µ–¥–µ–Ω–µ–Ω–∏—è —Å—É–¥–Ω–∞. 
/// –ú–æ–∂–µ—Ç –±—ã—Ç—å –±–µ–∑ –æ–±–ª–µ–¥–µ–Ω–µ–Ω–∏—è, —á–∞—Å—Ç–∏—á–Ω—ã–º –∏ –ø–æ–ª–Ω—ã–º.  
/// –ü—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ –æ–±–ª–µ–¥–µ–Ω–µ–Ω–∏—è –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É—á–∏—Ç—ã–≤–∞—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤–æ–¥–æ–∏–∑–º–µ—â–µ–Ω–∏—è –∏  
/// –≤–æ–∑–≤—ã—à–µ–Ω–∏—è —Ü–µ–Ω—Ç—Ä–∞ —Ç—è–∂–µ—Å—Ç–∏. –ü—Ä–∏ —É—á–µ—Ç–µ –æ–±–ª–µ–¥–µ–Ω–µ–Ω–∏—è –∫ –º–∞—Å—Å–µ —Å—É–¥–Ω–∞ –¥–æ–±–∞–≤–ª—è—é—Ç—Å—è  
/// –º–∞—Å—Å–∞ –ª—å–¥–∞ –Ω–∞ –±–æ—Ä—Ç–∞—Ö, –ø–∞–ª—É–±–∞—Ö, –ø–∞–ª—É–±–Ω–æ–º –≥—Ä—É–∑–µ. –ú–∞—Å—Å–∞ –ª—å–¥–∞ –∏ –µ–≥–æ –º–æ–º–µ–Ω—Ç—ã,  
/// —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞—é—Ç—Å—è –¥–ª—è –æ—Å–∞–¥–∫–∏ ùëëùëöùëñùëõ –∏ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—è—é—Ç—Å—è –Ω–∞ –≤—Å–µ —Å–ª—É—á–∞–∏ –∑–∞–≥—Ä—É–∑–∫–∏. 
pub struct IcingMoment {
    /// –¢–∏–ø –æ–±–ª–µ–¥–µ–Ω–µ–Ω–∏—è
    icing_stab: IcingStab,
    /// –í—Å–µ –≥—Ä—É–∑—ã —Å—É–¥–Ω–∞
    loads_cargo: Vec<Rc<Box<dyn ILoad>>>,
    /// –ü–ª–æ—â–∞–¥—å –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã—Ö –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–µ–π
    area_h: Vec<ParsedIcingArea>,
    /// –ü–ª–æ—â–∞–¥—å –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏ –ø–∞—Ä—É—Å–Ω–æ—Å—Ç–∏
    area_v: Vec<ParsedIcingArea>,
}
///
impl IcingMoment {
    /// –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä
    /// * icing_stab - –¢–∏–ø –æ–±–ª–µ–¥–µ–Ω–µ–Ω–∏—è
    /// * loads_cargo - –ì—Ä—É–∑—ã —Å—É–¥–Ω–∞
    /// * area_h - –ü–ª–æ—â–∞–¥—å –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã—Ö –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–µ–π
    /// * area_v - –ü–ª–æ—â–∞–¥—å –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏ –ø–∞—Ä—É—Å–Ω–æ—Å—Ç–∏
    pub fn new(
        icing_stab: IcingStab,
        loads_cargo: Vec<Rc<Box<dyn ILoad>>>,
        area_h: Vec<ParsedIcingArea>,
        area_v: Vec<ParsedIcingArea>,
    ) -> Self {
        Self{
            icing_stab, 
            loads_cargo,
            area_h,
            area_v,
        }
    }
    /// –°—É–º–º–∞—Ä–Ω–∞—è –º–∞—Å—Å–∞ –ª—å–¥–∞
    pub fn mass(&self, bound: Option<Bound>) -> f64 {
        
        if let Some(bound) = bound {
            self.bound_x.part_ratio(&bound) * self.mass
        } else {
            self.mass
        }
    }
    /// –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –º–∞—Å—Å—ã –ø–æ –≤–µ–∫—Ç–æ—Ä—É —Ä–∞–∑–±–∏–µ–Ω–∏—è
    fn values(&self) -> Vec<f64> {
    }
    /// –°—É–º–º–∞—Ä–Ω—ã–π —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π –º–æ–º–µ–Ω—Ç –º–∞—Å—Å—ã –ª—å–¥–∞.
    pub fn moment_mass(&self) -> Moment {
    }
    /// –û—Ç—Å—Ç–æ—è–Ω–∏–µ —Ü–µ–Ω—Ç—Ä–∞ –º–∞—Å—Å
    fn shift(&self) -> Position {
    }
    /// –†–∞—Å—á–µ—Ç –æ–±–ª–µ–¥–µ–Ω–µ–Ω–∏—è
    fn calculate(&mut self) {
        // –ú–∞—Å—Å–∞ –ª—å–¥–∞ –Ω–∞ –æ–±—â–µ–π –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–π –ø—Ä–æ–µ–∫—Ü–∏–∏ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø–∞–ª—É–± –∏ –ø–∞–ª—É–±–Ω–æ–≥–æ –≥—Ä—É–∑–∞, —Ç
        let p_h = self.desc_area;
        // –ú–æ–º–µ–Ω—Ç –º–∞—Å—Å—ã –ª—å–¥–∞ –Ω–∞ –æ–±—â–µ–π –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–π –ø—Ä–æ–µ–∫—Ü–∏–∏ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø–∞–ª—É–± –∏ –ø–∞–ª—É–±–Ω–æ–≥–æ –≥—Ä—É–∑–∞
        let m_x_h = ;
        let m_y_h = ;
        let m_z_h = ;
        // –ú–∞—Å—Å–∞ –ª—å–¥–∞ –Ω–∞ –ø–ª–æ—â–∞–¥–∏ –ø–∞—Ä—É—Å–Ω–æ—Å—Ç–∏, —Ç
        let p_v = (a_v_cs_dmin + a_v_ds) * self.w_v;
        // –ú–æ–º–µ–Ω—Ç –º–∞—Å—Å—ã –ª—å–¥–∞ –Ω–∞ –ø–ª–æ—â–∞–¥–∏ –ø–∞—Ä—É—Å–Ω–æ—Å—Ç–∏
        let m_x_v = (m_vx_cs_dmin + m_vx_ds) * self.icing_stab.mass_h();
        let m_z_v = (m_vz_cs_dmin + m_vz_ds) * self.icing_stab.mass_v();
        // –ú–∞—Å—Å–∞ –ª—å–¥–∞
        let p = p_h + p_v;
        // –ú–æ–º–µ–Ω—Ç –º–∞—Å—Å—ã –ª—å–¥–∞
        let m_x = m_x_h + m_x_v;
        let m_z = m_z_h + m_z_v;
    }
}
///
impl IIcing for Icing {
}
#[doc(hidden)]
pub trait IIcing {
}
// –∑–∞–≥–ª—É—à–∫–∞ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
#[doc(hidden)]
pub struct FakeIcing {

}
#[doc(hidden)]
#[allow(dead_code)]
impl FakeIcing {
    pub fn new(

    ) -> Self {
        Self {

        }
    }
}




